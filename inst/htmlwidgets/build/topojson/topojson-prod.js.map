{"version":3,"sources":["webpack://topojson/webpack/bootstrap","webpack://topojson/./node_modules/topojson/node_modules/topojson-client/src/identity.js","webpack://topojson/./node_modules/topojson/node_modules/topojson-client/src/transform.js","webpack://topojson/./node_modules/topojson/node_modules/topojson-client/src/bbox.js","webpack://topojson/./node_modules/topojson/node_modules/topojson-client/src/reverse.js","webpack://topojson/./node_modules/topojson/node_modules/topojson-client/src/feature.js","webpack://topojson/./node_modules/topojson/node_modules/topojson-client/src/stitch.js","webpack://topojson/./node_modules/topojson/node_modules/topojson-client/src/mesh.js","webpack://topojson/./node_modules/topojson/node_modules/topojson-client/src/merge.js","webpack://topojson/./node_modules/topojson/node_modules/topojson-client/src/bisect.js","webpack://topojson/./node_modules/topojson/node_modules/topojson-client/src/neighbors.js","webpack://topojson/./node_modules/topojson/node_modules/topojson-client/src/untransform.js","webpack://topojson/./node_modules/topojson/node_modules/topojson-client/src/quantize.js","webpack://topojson/./node_modules/topojson/node_modules/topojson-server/src/hash/hashmap.js","webpack://topojson/./node_modules/topojson/node_modules/topojson-server/src/hash/point-equal.js","webpack://topojson/./node_modules/topojson/node_modules/topojson-server/src/hash/point-hash.js","webpack://topojson/./node_modules/topojson/node_modules/topojson-server/src/join.js","webpack://topojson/./node_modules/topojson/node_modules/topojson-server/src/hash/hashset.js","webpack://topojson/./node_modules/topojson/node_modules/topojson-server/src/cut.js","webpack://topojson/./node_modules/topojson/node_modules/topojson-server/src/geometry.js","webpack://topojson/./node_modules/topojson/node_modules/topojson-server/src/prequantize.js","webpack://topojson/./node_modules/topojson/node_modules/topojson-server/src/topology.js","webpack://topojson/./node_modules/topojson/node_modules/topojson-server/src/bounds.js","webpack://topojson/./node_modules/topojson/node_modules/topojson-server/src/dedup.js","webpack://topojson/./node_modules/topojson/node_modules/topojson-server/src/extract.js","webpack://topojson/./node_modules/topojson/node_modules/topojson-server/src/delta.js","webpack://topojson/./node_modules/topojson/node_modules/topojson-simplify/src/prune.js","webpack://topojson/./node_modules/topojson/node_modules/topojson-simplify/src/filter.js","webpack://topojson/./node_modules/topojson/node_modules/topojson-simplify/src/filterAttached.js","webpack://topojson/./node_modules/topojson/node_modules/topojson-simplify/src/planar.js","webpack://topojson/./node_modules/topojson/node_modules/topojson-simplify/src/filterWeight.js","webpack://topojson/./node_modules/topojson/node_modules/topojson-simplify/src/filterAttachedWeight.js","webpack://topojson/./node_modules/topojson/node_modules/topojson-simplify/src/heap.js","webpack://topojson/./node_modules/topojson/node_modules/topojson-simplify/src/presimplify.js","webpack://topojson/./node_modules/topojson/node_modules/topojson-simplify/src/quantile.js","webpack://topojson/./node_modules/topojson/node_modules/topojson-simplify/src/simplify.js","webpack://topojson/./node_modules/topojson/node_modules/topojson-simplify/src/spherical.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","r","value","n","__esModule","object","property","prototype","hasOwnProperty","p","s","identity","x","src_transform","transform","x0","y0","kx","scale","ky","dx","translate","dy","input","j","length","output","Array","src_bbox","topology","key","t","Infinity","x1","y1","bboxPoint","bboxGeometry","type","geometries","forEach","coordinates","arcs","arc","objects","src_reverse","array","src_feature","features","map","feature_feature","id","bbox","properties","geometry","feature_object","transformPoint","points","pop","a","k","push","point","line","ring","polygon","stitch","stitchedArcs","fragmentByStart","fragmentByEnd","fragments","emptyIndex","flush","f","start","end","g","e","p1","p0","dp","ends","fg","concat","unshift","gf","mesh","mesh_meshArcs","apply","this","arguments","filter","geom","geomsByArc","extract0","extract1","extract2","geoms","mesh_extractArcs","merge","merge_mergeArcs","polygonsByArc","polygons","groups","extract","area","b","Math","abs","merge_planarRingArea","_","group","neighbors","ki","bisect","lo","hi","mid","src_neighbors","indexesByArc","geometryType","LineString","MultiLineString","Polygon","MultiPolygon","indexes","ij","ik","splice","untransform","round","quantize","Error","box","floor","inputs","outputs","quantizePoint","quantizeGeometry","hashmap","size","hash","equal","keyType","keyEmpty","valueType","keystore","max","ceil","log","LN2","valstore","mask","set","index","matchKey","collisions","maybeSet","missingValue","keys","point_equal","pointA","pointB","buffer","ArrayBuffer","floats","Float64Array","uints","Uint32Array","point_hash","join","currentIndex","nextIndex","lines","rings","indexByPoint","hashIndex","equalIndex","Int32Array","visitedByIndex","leftByIndex","rightByIndex","junctionByIndex","Int8Array","junctionCount","lineStart","lineEnd","sequence","ringStart","ringEnd","previousIndex","leftIndex","rightIndex","junctionByPoint","empty","store","add","match","has","values","hashset","cut_reverse","geomifyFeature","geomifyGeometry","src_topology","quantization","boundGeometry","boundGeometryType","GeometryCollection","Point","boundPoint","MultiPoint","boundLine","boundMultiLine","y","undefined","bounds","src_geometry","quantizePoints","pi","px","py","quantizeLine","quantizeRing","quantizePolygon","quantizeGeometryType","prequantize","arcCount","next","arcsByEnd","dedupLine","dedupRing","startPoint","endPoint","startArcs","startArc","endArcs","endArc","equalLine","reverseEqualLine","equalRing","reverseEqualRing","findMinimumOffset","arcA","arcB","ia","ib","ja","jb","ka","kb","minimum","minimumPoint","dedup","junctions","lineMid","0","1","ringMid","ringFixed","offset","cut","extractGeometry","extractGeometryType","extractLine","extractRing","extractMultiRing","src_extract","indexByArc","topology_hashArc","topology_equalArc","indexGeometry","indexGeometryType","slice","indexArcs","indexMultiArcs","delta","src_filter","oldObjects","newObjects","filterGeometry","filterRings","filter_filterIdentity","filter_filterNotNull","filterInteriorRing","filter_filterTrue","newArcs","oldArcs","oldArcsLength","oldIndex","newIndexByOldIndex","newArcsLength","newIndex","scanGeometry","scanArcs","scanMultiArcs","scanArc","reindexGeometry","reindexArcs","reindexMultiArcs","reindexArc","prune","filterAttached","ownerByArc","ownerIndex","testGeometry","testArcs","owner","planarTriangleArea","triangle","planar_planarRingArea","filterWeight","minWeight","weight","Number","MIN_VALUE","interior","filterAttachedWeight","w","compare","presimplify_copy","presimplify","heap","up","parent","down","child","removed","remove","src_heap","triangles","maxWeight","previous","update","src_quantile","isFinite","h","quantile","sort","descending","simplify","PI","tau","quarterPi","radians","atan2","cos","sin","halfArea","closed","lambda0","cosPhi0","sinPhi0","sum","lambda1","phi1","cosPhi1","sinPhi1","dLambda","sdLambda","adLambda","u","v","sphericalRingArea","sphericalTriangleArea"],"mappings":"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","file":"topojson-prod.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","export default function(x) {\n  return x;\n}\n","import identity from \"./identity\";\n\nexport default function(transform) {\n  if (transform == null) return identity;\n  var x0,\n      y0,\n      kx = transform.scale[0],\n      ky = transform.scale[1],\n      dx = transform.translate[0],\n      dy = transform.translate[1];\n  return function(input, i) {\n    if (!i) x0 = y0 = 0;\n    var j = 2, n = input.length, output = new Array(n);\n    output[0] = (x0 += input[0]) * kx + dx;\n    output[1] = (y0 += input[1]) * ky + dy;\n    while (j < n) output[j] = input[j], ++j;\n    return output;\n  };\n}\n","import transform from \"./transform\";\n\nexport default function(topology) {\n  var t = transform(topology.transform), key,\n      x0 = Infinity, y0 = x0, x1 = -x0, y1 = -x0;\n\n  function bboxPoint(p) {\n    p = t(p);\n    if (p[0] < x0) x0 = p[0];\n    if (p[0] > x1) x1 = p[0];\n    if (p[1] < y0) y0 = p[1];\n    if (p[1] > y1) y1 = p[1];\n  }\n\n  function bboxGeometry(o) {\n    switch (o.type) {\n      case \"GeometryCollection\": o.geometries.forEach(bboxGeometry); break;\n      case \"Point\": bboxPoint(o.coordinates); break;\n      case \"MultiPoint\": o.coordinates.forEach(bboxPoint); break;\n    }\n  }\n\n  topology.arcs.forEach(function(arc) {\n    var i = -1, n = arc.length, p;\n    while (++i < n) {\n      p = t(arc[i], i);\n      if (p[0] < x0) x0 = p[0];\n      if (p[0] > x1) x1 = p[0];\n      if (p[1] < y0) y0 = p[1];\n      if (p[1] > y1) y1 = p[1];\n    }\n  });\n\n  for (key in topology.objects) {\n    bboxGeometry(topology.objects[key]);\n  }\n\n  return [x0, y0, x1, y1];\n}\n","export default function(array, n) {\n  var t, j = array.length, i = j - n;\n  while (i < --j) t = array[i], array[i++] = array[j], array[j] = t;\n}\n","import reverse from \"./reverse\";\nimport transform from \"./transform\";\n\nexport default function(topology, o) {\n  return o.type === \"GeometryCollection\"\n      ? {type: \"FeatureCollection\", features: o.geometries.map(function(o) { return feature(topology, o); })}\n      : feature(topology, o);\n}\n\nexport function feature(topology, o) {\n  var id = o.id,\n      bbox = o.bbox,\n      properties = o.properties == null ? {} : o.properties,\n      geometry = object(topology, o);\n  return id == null && bbox == null ? {type: \"Feature\", properties: properties, geometry: geometry}\n      : bbox == null ? {type: \"Feature\", id: id, properties: properties, geometry: geometry}\n      : {type: \"Feature\", id: id, bbox: bbox, properties: properties, geometry: geometry};\n}\n\nexport function object(topology, o) {\n  var transformPoint = transform(topology.transform),\n      arcs = topology.arcs;\n\n  function arc(i, points) {\n    if (points.length) points.pop();\n    for (var a = arcs[i < 0 ? ~i : i], k = 0, n = a.length; k < n; ++k) {\n      points.push(transformPoint(a[k], k));\n    }\n    if (i < 0) reverse(points, n);\n  }\n\n  function point(p) {\n    return transformPoint(p);\n  }\n\n  function line(arcs) {\n    var points = [];\n    for (var i = 0, n = arcs.length; i < n; ++i) arc(arcs[i], points);\n    if (points.length < 2) points.push(points[0]); // This should never happen per the specification.\n    return points;\n  }\n\n  function ring(arcs) {\n    var points = line(arcs);\n    while (points.length < 4) points.push(points[0]); // This may happen if an arc has only two points.\n    return points;\n  }\n\n  function polygon(arcs) {\n    return arcs.map(ring);\n  }\n\n  function geometry(o) {\n    var type = o.type, coordinates;\n    switch (type) {\n      case \"GeometryCollection\": return {type: type, geometries: o.geometries.map(geometry)};\n      case \"Point\": coordinates = point(o.coordinates); break;\n      case \"MultiPoint\": coordinates = o.coordinates.map(point); break;\n      case \"LineString\": coordinates = line(o.arcs); break;\n      case \"MultiLineString\": coordinates = o.arcs.map(line); break;\n      case \"Polygon\": coordinates = polygon(o.arcs); break;\n      case \"MultiPolygon\": coordinates = o.arcs.map(polygon); break;\n      default: return null;\n    }\n    return {type: type, coordinates: coordinates};\n  }\n\n  return geometry(o);\n}\n","export default function(topology, arcs) {\n  var stitchedArcs = {},\n      fragmentByStart = {},\n      fragmentByEnd = {},\n      fragments = [],\n      emptyIndex = -1;\n\n  // Stitch empty arcs first, since they may be subsumed by other arcs.\n  arcs.forEach(function(i, j) {\n    var arc = topology.arcs[i < 0 ? ~i : i], t;\n    if (arc.length < 3 && !arc[1][0] && !arc[1][1]) {\n      t = arcs[++emptyIndex], arcs[emptyIndex] = i, arcs[j] = t;\n    }\n  });\n\n  arcs.forEach(function(i) {\n    var e = ends(i),\n        start = e[0],\n        end = e[1],\n        f, g;\n\n    if (f = fragmentByEnd[start]) {\n      delete fragmentByEnd[f.end];\n      f.push(i);\n      f.end = end;\n      if (g = fragmentByStart[end]) {\n        delete fragmentByStart[g.start];\n        var fg = g === f ? f : f.concat(g);\n        fragmentByStart[fg.start = f.start] = fragmentByEnd[fg.end = g.end] = fg;\n      } else {\n        fragmentByStart[f.start] = fragmentByEnd[f.end] = f;\n      }\n    } else if (f = fragmentByStart[end]) {\n      delete fragmentByStart[f.start];\n      f.unshift(i);\n      f.start = start;\n      if (g = fragmentByEnd[start]) {\n        delete fragmentByEnd[g.end];\n        var gf = g === f ? f : g.concat(f);\n        fragmentByStart[gf.start = g.start] = fragmentByEnd[gf.end = f.end] = gf;\n      } else {\n        fragmentByStart[f.start] = fragmentByEnd[f.end] = f;\n      }\n    } else {\n      f = [i];\n      fragmentByStart[f.start = start] = fragmentByEnd[f.end = end] = f;\n    }\n  });\n\n  function ends(i) {\n    var arc = topology.arcs[i < 0 ? ~i : i], p0 = arc[0], p1;\n    if (topology.transform) p1 = [0, 0], arc.forEach(function(dp) { p1[0] += dp[0], p1[1] += dp[1]; });\n    else p1 = arc[arc.length - 1];\n    return i < 0 ? [p1, p0] : [p0, p1];\n  }\n\n  function flush(fragmentByEnd, fragmentByStart) {\n    for (var k in fragmentByEnd) {\n      var f = fragmentByEnd[k];\n      delete fragmentByStart[f.start];\n      delete f.start;\n      delete f.end;\n      f.forEach(function(i) { stitchedArcs[i < 0 ? ~i : i] = 1; });\n      fragments.push(f);\n    }\n  }\n\n  flush(fragmentByEnd, fragmentByStart);\n  flush(fragmentByStart, fragmentByEnd);\n  arcs.forEach(function(i) { if (!stitchedArcs[i < 0 ? ~i : i]) fragments.push([i]); });\n\n  return fragments;\n}\n","import {object} from \"./feature\";\nimport stitch from \"./stitch\";\n\nexport default function(topology) {\n  return object(topology, meshArcs.apply(this, arguments));\n}\n\nexport function meshArcs(topology, object, filter) {\n  var arcs, i, n;\n  if (arguments.length > 1) arcs = extractArcs(topology, object, filter);\n  else for (i = 0, arcs = new Array(n = topology.arcs.length); i < n; ++i) arcs[i] = i;\n  return {type: \"MultiLineString\", arcs: stitch(topology, arcs)};\n}\n\nfunction extractArcs(topology, object, filter) {\n  var arcs = [],\n      geomsByArc = [],\n      geom;\n\n  function extract0(i) {\n    var j = i < 0 ? ~i : i;\n    (geomsByArc[j] || (geomsByArc[j] = [])).push({i: i, g: geom});\n  }\n\n  function extract1(arcs) {\n    arcs.forEach(extract0);\n  }\n\n  function extract2(arcs) {\n    arcs.forEach(extract1);\n  }\n\n  function extract3(arcs) {\n    arcs.forEach(extract2);\n  }\n\n  function geometry(o) {\n    switch (geom = o, o.type) {\n      case \"GeometryCollection\": o.geometries.forEach(geometry); break;\n      case \"LineString\": extract1(o.arcs); break;\n      case \"MultiLineString\": case \"Polygon\": extract2(o.arcs); break;\n      case \"MultiPolygon\": extract3(o.arcs); break;\n    }\n  }\n\n  geometry(object);\n\n  geomsByArc.forEach(filter == null\n      ? function(geoms) { arcs.push(geoms[0].i); }\n      : function(geoms) { if (filter(geoms[0].g, geoms[geoms.length - 1].g)) arcs.push(geoms[0].i); });\n\n  return arcs;\n}\n","import {object} from \"./feature\";\nimport stitch from \"./stitch\";\n\nfunction planarRingArea(ring) {\n  var i = -1, n = ring.length, a, b = ring[n - 1], area = 0;\n  while (++i < n) a = b, b = ring[i], area += a[0] * b[1] - a[1] * b[0];\n  return Math.abs(area); // Note: doubled area!\n}\n\nexport default function(topology) {\n  return object(topology, mergeArcs.apply(this, arguments));\n}\n\nexport function mergeArcs(topology, objects) {\n  var polygonsByArc = {},\n      polygons = [],\n      groups = [];\n\n  objects.forEach(geometry);\n\n  function geometry(o) {\n    switch (o.type) {\n      case \"GeometryCollection\": o.geometries.forEach(geometry); break;\n      case \"Polygon\": extract(o.arcs); break;\n      case \"MultiPolygon\": o.arcs.forEach(extract); break;\n    }\n  }\n\n  function extract(polygon) {\n    polygon.forEach(function(ring) {\n      ring.forEach(function(arc) {\n        (polygonsByArc[arc = arc < 0 ? ~arc : arc] || (polygonsByArc[arc] = [])).push(polygon);\n      });\n    });\n    polygons.push(polygon);\n  }\n\n  function area(ring) {\n    return planarRingArea(object(topology, {type: \"Polygon\", arcs: [ring]}).coordinates[0]);\n  }\n\n  polygons.forEach(function(polygon) {\n    if (!polygon._) {\n      var group = [],\n          neighbors = [polygon];\n      polygon._ = 1;\n      groups.push(group);\n      while (polygon = neighbors.pop()) {\n        group.push(polygon);\n        polygon.forEach(function(ring) {\n          ring.forEach(function(arc) {\n            polygonsByArc[arc < 0 ? ~arc : arc].forEach(function(polygon) {\n              if (!polygon._) {\n                polygon._ = 1;\n                neighbors.push(polygon);\n              }\n            });\n          });\n        });\n      }\n    }\n  });\n\n  polygons.forEach(function(polygon) {\n    delete polygon._;\n  });\n\n  return {\n    type: \"MultiPolygon\",\n    arcs: groups.map(function(polygons) {\n      var arcs = [], n;\n\n      // Extract the exterior (unique) arcs.\n      polygons.forEach(function(polygon) {\n        polygon.forEach(function(ring) {\n          ring.forEach(function(arc) {\n            if (polygonsByArc[arc < 0 ? ~arc : arc].length < 2) {\n              arcs.push(arc);\n            }\n          });\n        });\n      });\n\n      // Stitch the arcs into one or more rings.\n      arcs = stitch(topology, arcs);\n\n      // If more than one ring is returned,\n      // at most one of these rings can be the exterior;\n      // choose the one with the greatest absolute area.\n      if ((n = arcs.length) > 1) {\n        for (var i = 1, k = area(arcs[0]), ki, t; i < n; ++i) {\n          if ((ki = area(arcs[i])) > k) {\n            t = arcs[0], arcs[0] = arcs[i], arcs[i] = t, k = ki;\n          }\n        }\n      }\n\n      return arcs;\n    })\n  };\n}\n","export default function(a, x) {\n  var lo = 0, hi = a.length;\n  while (lo < hi) {\n    var mid = lo + hi >>> 1;\n    if (a[mid] < x) lo = mid + 1;\n    else hi = mid;\n  }\n  return lo;\n}\n","import bisect from \"./bisect\";\n\nexport default function(objects) {\n  var indexesByArc = {}, // arc index -> array of object indexes\n      neighbors = objects.map(function() { return []; });\n\n  function line(arcs, i) {\n    arcs.forEach(function(a) {\n      if (a < 0) a = ~a;\n      var o = indexesByArc[a];\n      if (o) o.push(i);\n      else indexesByArc[a] = [i];\n    });\n  }\n\n  function polygon(arcs, i) {\n    arcs.forEach(function(arc) { line(arc, i); });\n  }\n\n  function geometry(o, i) {\n    if (o.type === \"GeometryCollection\") o.geometries.forEach(function(o) { geometry(o, i); });\n    else if (o.type in geometryType) geometryType[o.type](o.arcs, i);\n  }\n\n  var geometryType = {\n    LineString: line,\n    MultiLineString: polygon,\n    Polygon: polygon,\n    MultiPolygon: function(arcs, i) { arcs.forEach(function(arc) { polygon(arc, i); }); }\n  };\n\n  objects.forEach(geometry);\n\n  for (var i in indexesByArc) {\n    for (var indexes = indexesByArc[i], m = indexes.length, j = 0; j < m; ++j) {\n      for (var k = j + 1; k < m; ++k) {\n        var ij = indexes[j], ik = indexes[k], n;\n        if ((n = neighbors[ij])[i = bisect(n, ik)] !== ik) n.splice(i, 0, ik);\n        if ((n = neighbors[ik])[i = bisect(n, ij)] !== ij) n.splice(i, 0, ij);\n      }\n    }\n  }\n\n  return neighbors;\n}\n","import identity from \"./identity\";\n\nexport default function(transform) {\n  if (transform == null) return identity;\n  var x0,\n      y0,\n      kx = transform.scale[0],\n      ky = transform.scale[1],\n      dx = transform.translate[0],\n      dy = transform.translate[1];\n  return function(input, i) {\n    if (!i) x0 = y0 = 0;\n    var j = 2,\n        n = input.length,\n        output = new Array(n),\n        x1 = Math.round((input[0] - dx) / kx),\n        y1 = Math.round((input[1] - dy) / ky);\n    output[0] = x1 - x0, x0 = x1;\n    output[1] = y1 - y0, y0 = y1;\n    while (j < n) output[j] = input[j], ++j;\n    return output;\n  };\n}\n","import bbox from \"./bbox\";\nimport untransform from \"./untransform\";\n\nexport default function(topology, transform) {\n  if (topology.transform) throw new Error(\"already quantized\");\n\n  if (!transform || !transform.scale) {\n    if (!((n = Math.floor(transform)) >= 2)) throw new Error(\"n must be 2\");\n    box = topology.bbox || bbox(topology);\n    var x0 = box[0], y0 = box[1], x1 = box[2], y1 = box[3], n;\n    transform = {scale: [x1 - x0 ? (x1 - x0) / (n - 1) : 1, y1 - y0 ? (y1 - y0) / (n - 1) : 1], translate: [x0, y0]};\n  } else {\n    box = topology.bbox;\n  }\n\n  var t = untransform(transform), box, key, inputs = topology.objects, outputs = {};\n\n  function quantizePoint(point) {\n    return t(point);\n  }\n\n  function quantizeGeometry(input) {\n    var output;\n    switch (input.type) {\n      case \"GeometryCollection\": output = {type: \"GeometryCollection\", geometries: input.geometries.map(quantizeGeometry)}; break;\n      case \"Point\": output = {type: \"Point\", coordinates: quantizePoint(input.coordinates)}; break;\n      case \"MultiPoint\": output = {type: \"MultiPoint\", coordinates: input.coordinates.map(quantizePoint)}; break;\n      default: return input;\n    }\n    if (input.id != null) output.id = input.id;\n    if (input.bbox != null) output.bbox = input.bbox;\n    if (input.properties != null) output.properties = input.properties;\n    return output;\n  }\n\n  function quantizeArc(input) {\n    var i = 0, j = 1, n = input.length, p, output = new Array(n); // pessimistic\n    output[0] = t(input[0], 0);\n    while (++i < n) if ((p = t(input[i], i))[0] || p[1]) output[j++] = p; // non-coincident points\n    if (j === 1) output[j++] = [0, 0]; // an arc must have at least two points\n    output.length = j;\n    return output;\n  }\n\n  for (key in inputs) outputs[key] = quantizeGeometry(inputs[key]);\n\n  return {\n    type: \"Topology\",\n    bbox: box,\n    transform: transform,\n    objects: outputs,\n    arcs: topology.arcs.map(quantizeArc)\n  };\n}\n","export default function(size, hash, equal, keyType, keyEmpty, valueType) {\n  if (arguments.length === 3) {\n    keyType = valueType = Array;\n    keyEmpty = null;\n  }\n\n  var keystore = new keyType(size = 1 << Math.max(4, Math.ceil(Math.log(size) / Math.LN2))),\n      valstore = new valueType(size),\n      mask = size - 1;\n\n  for (var i = 0; i < size; ++i) {\n    keystore[i] = keyEmpty;\n  }\n\n  function set(key, value) {\n    var index = hash(key) & mask,\n        matchKey = keystore[index],\n        collisions = 0;\n    while (matchKey != keyEmpty) {\n      if (equal(matchKey, key)) return valstore[index] = value;\n      if (++collisions >= size) throw new Error(\"full hashmap\");\n      matchKey = keystore[index = (index + 1) & mask];\n    }\n    keystore[index] = key;\n    valstore[index] = value;\n    return value;\n  }\n\n  function maybeSet(key, value) {\n    var index = hash(key) & mask,\n        matchKey = keystore[index],\n        collisions = 0;\n    while (matchKey != keyEmpty) {\n      if (equal(matchKey, key)) return valstore[index];\n      if (++collisions >= size) throw new Error(\"full hashmap\");\n      matchKey = keystore[index = (index + 1) & mask];\n    }\n    keystore[index] = key;\n    valstore[index] = value;\n    return value;\n  }\n\n  function get(key, missingValue) {\n    var index = hash(key) & mask,\n        matchKey = keystore[index],\n        collisions = 0;\n    while (matchKey != keyEmpty) {\n      if (equal(matchKey, key)) return valstore[index];\n      if (++collisions >= size) break;\n      matchKey = keystore[index = (index + 1) & mask];\n    }\n    return missingValue;\n  }\n\n  function keys() {\n    var keys = [];\n    for (var i = 0, n = keystore.length; i < n; ++i) {\n      var matchKey = keystore[i];\n      if (matchKey != keyEmpty) keys.push(matchKey);\n    }\n    return keys;\n  }\n\n  return {\n    set: set,\n    maybeSet: maybeSet, // set if unset\n    get: get,\n    keys: keys\n  };\n}\n","export default function(pointA, pointB) {\n  return pointA[0] === pointB[0] && pointA[1] === pointB[1];\n}\n","// TODO if quantized, use simpler Int32 hashing?\n\nvar buffer = new ArrayBuffer(16),\n    floats = new Float64Array(buffer),\n    uints = new Uint32Array(buffer);\n\nexport default function(point) {\n  floats[0] = point[0];\n  floats[1] = point[1];\n  var hash = uints[0] ^ uints[1];\n  hash = hash << 5 ^ hash >> 7 ^ uints[2] ^ uints[3];\n  return hash & 0x7fffffff;\n}\n","import hashset from \"./hash/hashset\";\nimport hashmap from \"./hash/hashmap\";\nimport equalPoint from \"./hash/point-equal\";\nimport hashPoint from \"./hash/point-hash\";\n\n// Given an extracted (pre-)topology, identifies all of the junctions. These are\n// the points at which arcs (lines or rings) will need to be cut so that each\n// arc is represented uniquely.\n//\n// A junction is a point where at least one arc deviates from another arc going\n// through the same point. For example, consider the point B. If there is a arc\n// through ABC and another arc through CBA, then B is not a junction because in\n// both cases the adjacent point pairs are {A,C}. However, if there is an\n// additional arc ABD, then {A,D} != {A,C}, and thus B becomes a junction.\n//\n// For a closed ring ABCA, the first point As adjacent points are the second\n// and last point {B,C}. For a line, the first and last point are always\n// considered junctions, even if the line is closed; this ensures that a closed\n// line is never rotated.\nexport default function(topology) {\n  var coordinates = topology.coordinates,\n      lines = topology.lines,\n      rings = topology.rings,\n      indexes = index(),\n      visitedByIndex = new Int32Array(coordinates.length),\n      leftByIndex = new Int32Array(coordinates.length),\n      rightByIndex = new Int32Array(coordinates.length),\n      junctionByIndex = new Int8Array(coordinates.length),\n      junctionCount = 0, // upper bound on number of junctions\n      i, n,\n      previousIndex,\n      currentIndex,\n      nextIndex;\n\n  for (i = 0, n = coordinates.length; i < n; ++i) {\n    visitedByIndex[i] = leftByIndex[i] = rightByIndex[i] = -1;\n  }\n\n  for (i = 0, n = lines.length; i < n; ++i) {\n    var line = lines[i],\n        lineStart = line[0],\n        lineEnd = line[1];\n    currentIndex = indexes[lineStart];\n    nextIndex = indexes[++lineStart];\n    ++junctionCount, junctionByIndex[currentIndex] = 1; // start\n    while (++lineStart <= lineEnd) {\n      sequence(i, previousIndex = currentIndex, currentIndex = nextIndex, nextIndex = indexes[lineStart]);\n    }\n    ++junctionCount, junctionByIndex[nextIndex] = 1; // end\n  }\n\n  for (i = 0, n = coordinates.length; i < n; ++i) {\n    visitedByIndex[i] = -1;\n  }\n\n  for (i = 0, n = rings.length; i < n; ++i) {\n    var ring = rings[i],\n        ringStart = ring[0] + 1,\n        ringEnd = ring[1];\n    previousIndex = indexes[ringEnd - 1];\n    currentIndex = indexes[ringStart - 1];\n    nextIndex = indexes[ringStart];\n    sequence(i, previousIndex, currentIndex, nextIndex);\n    while (++ringStart <= ringEnd) {\n      sequence(i, previousIndex = currentIndex, currentIndex = nextIndex, nextIndex = indexes[ringStart]);\n    }\n  }\n\n  function sequence(i, previousIndex, currentIndex, nextIndex) {\n    if (visitedByIndex[currentIndex] === i) return; // ignore self-intersection\n    visitedByIndex[currentIndex] = i;\n    var leftIndex = leftByIndex[currentIndex];\n    if (leftIndex >= 0) {\n      var rightIndex = rightByIndex[currentIndex];\n      if ((leftIndex !== previousIndex || rightIndex !== nextIndex)\n        && (leftIndex !== nextIndex || rightIndex !== previousIndex)) {\n        ++junctionCount, junctionByIndex[currentIndex] = 1;\n      }\n    } else {\n      leftByIndex[currentIndex] = previousIndex;\n      rightByIndex[currentIndex] = nextIndex;\n    }\n  }\n\n  function index() {\n    var indexByPoint = hashmap(coordinates.length * 1.4, hashIndex, equalIndex, Int32Array, -1, Int32Array),\n        indexes = new Int32Array(coordinates.length);\n\n    for (var i = 0, n = coordinates.length; i < n; ++i) {\n      indexes[i] = indexByPoint.maybeSet(i, i);\n    }\n\n    return indexes;\n  }\n\n  function hashIndex(i) {\n    return hashPoint(coordinates[i]);\n  }\n\n  function equalIndex(i, j) {\n    return equalPoint(coordinates[i], coordinates[j]);\n  }\n\n  visitedByIndex = leftByIndex = rightByIndex = null;\n\n  var junctionByPoint = hashset(junctionCount * 1.4, hashPoint, equalPoint), j;\n\n  // Convert back to a standard hashset by point for caller convenience.\n  for (i = 0, n = coordinates.length; i < n; ++i) {\n    if (junctionByIndex[j = indexes[i]]) {\n      junctionByPoint.add(coordinates[j]);\n    }\n  }\n\n  return junctionByPoint;\n}\n","export default function(size, hash, equal, type, empty) {\n  if (arguments.length === 3) {\n    type = Array;\n    empty = null;\n  }\n\n  var store = new type(size = 1 << Math.max(4, Math.ceil(Math.log(size) / Math.LN2))),\n      mask = size - 1;\n\n  for (var i = 0; i < size; ++i) {\n    store[i] = empty;\n  }\n\n  function add(value) {\n    var index = hash(value) & mask,\n        match = store[index],\n        collisions = 0;\n    while (match != empty) {\n      if (equal(match, value)) return true;\n      if (++collisions >= size) throw new Error(\"full hashset\");\n      match = store[index = (index + 1) & mask];\n    }\n    store[index] = value;\n    return true;\n  }\n\n  function has(value) {\n    var index = hash(value) & mask,\n        match = store[index],\n        collisions = 0;\n    while (match != empty) {\n      if (equal(match, value)) return true;\n      if (++collisions >= size) break;\n      match = store[index = (index + 1) & mask];\n    }\n    return false;\n  }\n\n  function values() {\n    var values = [];\n    for (var i = 0, n = store.length; i < n; ++i) {\n      var match = store[i];\n      if (match != empty) values.push(match);\n    }\n    return values;\n  }\n\n  return {\n    add: add,\n    has: has,\n    values: values\n  };\n}\n","import join from \"./join\";\n\n// Given an extracted (pre-)topology, cuts (or rotates) arcs so that all shared\n// point sequences are identified. The topology can then be subsequently deduped\n// to remove exact duplicate arcs.\nexport default function(topology) {\n  var junctions = join(topology),\n      coordinates = topology.coordinates,\n      lines = topology.lines,\n      rings = topology.rings,\n      next,\n      i, n;\n\n  for (i = 0, n = lines.length; i < n; ++i) {\n    var line = lines[i],\n        lineMid = line[0],\n        lineEnd = line[1];\n    while (++lineMid < lineEnd) {\n      if (junctions.has(coordinates[lineMid])) {\n        next = {0: lineMid, 1: line[1]};\n        line[1] = lineMid;\n        line = line.next = next;\n      }\n    }\n  }\n\n  for (i = 0, n = rings.length; i < n; ++i) {\n    var ring = rings[i],\n        ringStart = ring[0],\n        ringMid = ringStart,\n        ringEnd = ring[1],\n        ringFixed = junctions.has(coordinates[ringStart]);\n    while (++ringMid < ringEnd) {\n      if (junctions.has(coordinates[ringMid])) {\n        if (ringFixed) {\n          next = {0: ringMid, 1: ring[1]};\n          ring[1] = ringMid;\n          ring = ring.next = next;\n        } else { // For the first junction, we can rotate rather than cut.\n          rotateArray(coordinates, ringStart, ringEnd, ringEnd - ringMid);\n          coordinates[ringEnd] = coordinates[ringStart];\n          ringFixed = true;\n          ringMid = ringStart; // restart; we may have skipped junctions\n        }\n      }\n    }\n  }\n\n  return topology;\n}\n\nfunction rotateArray(array, start, end, offset) {\n  reverse(array, start, end);\n  reverse(array, start, start + offset);\n  reverse(array, start + offset, end);\n}\n\nfunction reverse(array, start, end) {\n  for (var mid = start + ((end-- - start) >> 1), t; start < mid; ++start, --end) {\n    t = array[start], array[start] = array[end], array[end] = t;\n  }\n}\n","// Given a hash of GeoJSON objects, returns a hash of GeoJSON geometry objects.\n// Any null input geometry objects are represented as {type: null} in the output.\n// Any feature.{id,properties,bbox} are transferred to the output geometry object.\n// Each output geometry object is a shallow copy of the input (e.g., properties, coordinates)!\nexport default function(inputs) {\n  var outputs = {}, key;\n  for (key in inputs) outputs[key] = geomifyObject(inputs[key]);\n  return outputs;\n}\n\nfunction geomifyObject(input) {\n  return input == null ? {type: null}\n      : (input.type === \"FeatureCollection\" ? geomifyFeatureCollection\n      : input.type === \"Feature\" ? geomifyFeature\n      : geomifyGeometry)(input);\n}\n\nfunction geomifyFeatureCollection(input) {\n  var output = {type: \"GeometryCollection\", geometries: input.features.map(geomifyFeature)};\n  if (input.bbox != null) output.bbox = input.bbox;\n  return output;\n}\n\nfunction geomifyFeature(input) {\n  var output = geomifyGeometry(input.geometry), key; // eslint-disable-line no-unused-vars\n  if (input.id != null) output.id = input.id;\n  if (input.bbox != null) output.bbox = input.bbox;\n  for (key in input.properties) { output.properties = input.properties; break; }\n  return output;\n}\n\nfunction geomifyGeometry(input) {\n  if (input == null) return {type: null};\n  var output = input.type === \"GeometryCollection\" ? {type: \"GeometryCollection\", geometries: input.geometries.map(geomifyGeometry)}\n      : input.type === \"Point\" || input.type === \"MultiPoint\" ? {type: input.type, coordinates: input.coordinates}\n      : {type: input.type, arcs: input.coordinates}; // TODO Check for unknown types?\n  if (input.bbox != null) output.bbox = input.bbox;\n  return output;\n}\n","export default function(objects, bbox, n) {\n  var x0 = bbox[0],\n      y0 = bbox[1],\n      x1 = bbox[2],\n      y1 = bbox[3],\n      kx = x1 - x0 ? (n - 1) / (x1 - x0) : 1,\n      ky = y1 - y0 ? (n - 1) / (y1 - y0) : 1;\n\n  function quantizePoint(input) {\n    return [Math.round((input[0] - x0) * kx), Math.round((input[1] - y0) * ky)];\n  }\n\n  function quantizePoints(input, m) {\n    var i = -1,\n        j = 0,\n        n = input.length,\n        output = new Array(n), // pessimistic\n        pi,\n        px,\n        py,\n        x,\n        y;\n\n    while (++i < n) {\n      pi = input[i];\n      x = Math.round((pi[0] - x0) * kx);\n      y = Math.round((pi[1] - y0) * ky);\n      if (x !== px || y !== py) output[j++] = [px = x, py = y]; // non-coincident points\n    }\n\n    output.length = j;\n    while (j < m) j = output.push([output[0][0], output[0][1]]);\n    return output;\n  }\n\n  function quantizeLine(input) {\n    return quantizePoints(input, 2);\n  }\n\n  function quantizeRing(input) {\n    return quantizePoints(input, 4);\n  }\n\n  function quantizePolygon(input) {\n    return input.map(quantizeRing);\n  }\n\n  function quantizeGeometry(o) {\n    if (o != null && quantizeGeometryType.hasOwnProperty(o.type)) quantizeGeometryType[o.type](o);\n  }\n\n  var quantizeGeometryType = {\n    GeometryCollection: function(o) { o.geometries.forEach(quantizeGeometry); },\n    Point: function(o) { o.coordinates = quantizePoint(o.coordinates); },\n    MultiPoint: function(o) { o.coordinates = o.coordinates.map(quantizePoint); },\n    LineString: function(o) { o.arcs = quantizeLine(o.arcs); },\n    MultiLineString: function(o) { o.arcs = o.arcs.map(quantizeLine); },\n    Polygon: function(o) { o.arcs = quantizePolygon(o.arcs); },\n    MultiPolygon: function(o) { o.arcs = o.arcs.map(quantizePolygon); }\n  };\n\n  for (var key in objects) {\n    quantizeGeometry(objects[key]);\n  }\n\n  return {\n    scale: [1 / kx, 1 / ky],\n    translate: [x0, y0]\n  };\n}\n","import bounds from \"./bounds\";\nimport cut from \"./cut\";\nimport dedup from \"./dedup\";\nimport delta from \"./delta\";\nimport extract from \"./extract\";\nimport geometry from \"./geometry\";\nimport hashmap from \"./hash/hashmap\";\nimport prequantize from \"./prequantize\";\n\n// Constructs the TopoJSON Topology for the specified hash of features.\n// Each object in the specified hash must be a GeoJSON object,\n// meaning FeatureCollection, a Feature or a geometry object.\nexport default function(objects, quantization) {\n  var bbox = bounds(objects = geometry(objects)),\n      transform = quantization > 0 && bbox && prequantize(objects, bbox, quantization),\n      topology = dedup(cut(extract(objects))),\n      coordinates = topology.coordinates,\n      indexByArc = hashmap(topology.arcs.length * 1.4, hashArc, equalArc);\n\n  objects = topology.objects; // for garbage collection\n  topology.bbox = bbox;\n  topology.arcs = topology.arcs.map(function(arc, i) {\n    indexByArc.set(arc, i);\n    return coordinates.slice(arc[0], arc[1] + 1);\n  });\n\n  delete topology.coordinates;\n  coordinates = null;\n\n  function indexGeometry(geometry) {\n    if (geometry && indexGeometryType.hasOwnProperty(geometry.type)) indexGeometryType[geometry.type](geometry);\n  }\n\n  var indexGeometryType = {\n    GeometryCollection: function(o) { o.geometries.forEach(indexGeometry); },\n    LineString: function(o) { o.arcs = indexArcs(o.arcs); },\n    MultiLineString: function(o) { o.arcs = o.arcs.map(indexArcs); },\n    Polygon: function(o) { o.arcs = o.arcs.map(indexArcs); },\n    MultiPolygon: function(o) { o.arcs = o.arcs.map(indexMultiArcs); }\n  };\n\n  function indexArcs(arc) {\n    var indexes = [];\n    do {\n      var index = indexByArc.get(arc);\n      indexes.push(arc[0] < arc[1] ? index : ~index);\n    } while (arc = arc.next);\n    return indexes;\n  }\n\n  function indexMultiArcs(arcs) {\n    return arcs.map(indexArcs);\n  }\n\n  for (var key in objects) {\n    indexGeometry(objects[key]);\n  }\n\n  if (transform) {\n    topology.transform = transform;\n    topology.arcs = delta(topology.arcs);\n  }\n\n  return topology;\n}\n\nfunction hashArc(arc) {\n  var i = arc[0], j = arc[1], t;\n  if (j < i) t = i, i = j, j = t;\n  return i + 31 * j;\n}\n\nfunction equalArc(arcA, arcB) {\n  var ia = arcA[0], ja = arcA[1],\n      ib = arcB[0], jb = arcB[1], t;\n  if (ja < ia) t = ia, ia = ja, ja = t;\n  if (jb < ib) t = ib, ib = jb, jb = t;\n  return ia === ib && ja === jb;\n}\n","// Computes the bounding box of the specified hash of GeoJSON objects.\nexport default function(objects) {\n  var x0 = Infinity,\n      y0 = Infinity,\n      x1 = -Infinity,\n      y1 = -Infinity;\n\n  function boundGeometry(geometry) {\n    if (geometry != null && boundGeometryType.hasOwnProperty(geometry.type)) boundGeometryType[geometry.type](geometry);\n  }\n\n  var boundGeometryType = {\n    GeometryCollection: function(o) { o.geometries.forEach(boundGeometry); },\n    Point: function(o) { boundPoint(o.coordinates); },\n    MultiPoint: function(o) { o.coordinates.forEach(boundPoint); },\n    LineString: function(o) { boundLine(o.arcs); },\n    MultiLineString: function(o) { o.arcs.forEach(boundLine); },\n    Polygon: function(o) { o.arcs.forEach(boundLine); },\n    MultiPolygon: function(o) { o.arcs.forEach(boundMultiLine); }\n  };\n\n  function boundPoint(coordinates) {\n    var x = coordinates[0],\n        y = coordinates[1];\n    if (x < x0) x0 = x;\n    if (x > x1) x1 = x;\n    if (y < y0) y0 = y;\n    if (y > y1) y1 = y;\n  }\n\n  function boundLine(coordinates) {\n    coordinates.forEach(boundPoint);\n  }\n\n  function boundMultiLine(coordinates) {\n    coordinates.forEach(boundLine);\n  }\n\n  for (var key in objects) {\n    boundGeometry(objects[key]);\n  }\n\n  return x1 >= x0 && y1 >= y0 ? [x0, y0, x1, y1] : undefined;\n}\n","import hashmap from \"./hash/hashmap\";\nimport equalPoint from \"./hash/point-equal\";\nimport hashPoint from \"./hash/point-hash\";\n\n// Given a cut topology, combines duplicate arcs.\nexport default function(topology) {\n  var coordinates = topology.coordinates,\n      lines = topology.lines, line,\n      rings = topology.rings, ring,\n      arcCount = lines.length + rings.length,\n      i, n;\n\n  delete topology.lines;\n  delete topology.rings;\n\n  // Count the number of (non-unique) arcs to initialize the hashmap safely.\n  for (i = 0, n = lines.length; i < n; ++i) {\n    line = lines[i]; while (line = line.next) ++arcCount;\n  }\n  for (i = 0, n = rings.length; i < n; ++i) {\n    ring = rings[i]; while (ring = ring.next) ++arcCount;\n  }\n\n  var arcsByEnd = hashmap(arcCount * 2 * 1.4, hashPoint, equalPoint),\n      arcs = topology.arcs = [];\n\n  for (i = 0, n = lines.length; i < n; ++i) {\n    line = lines[i];\n    do {\n      dedupLine(line);\n    } while (line = line.next);\n  }\n\n  for (i = 0, n = rings.length; i < n; ++i) {\n    ring = rings[i];\n    if (ring.next) { // arc is no longer closed\n      do {\n        dedupLine(ring);\n      } while (ring = ring.next);\n    } else {\n      dedupRing(ring);\n    }\n  }\n\n  function dedupLine(arc) {\n    var startPoint,\n        endPoint,\n        startArcs, startArc,\n        endArcs, endArc,\n        i, n;\n\n    // Does this arc match an existing arc in order?\n    if (startArcs = arcsByEnd.get(startPoint = coordinates[arc[0]])) {\n      for (i = 0, n = startArcs.length; i < n; ++i) {\n        startArc = startArcs[i];\n        if (equalLine(startArc, arc)) {\n          arc[0] = startArc[0];\n          arc[1] = startArc[1];\n          return;\n        }\n      }\n    }\n\n    // Does this arc match an existing arc in reverse order?\n    if (endArcs = arcsByEnd.get(endPoint = coordinates[arc[1]])) {\n      for (i = 0, n = endArcs.length; i < n; ++i) {\n        endArc = endArcs[i];\n        if (reverseEqualLine(endArc, arc)) {\n          arc[1] = endArc[0];\n          arc[0] = endArc[1];\n          return;\n        }\n      }\n    }\n\n    if (startArcs) startArcs.push(arc); else arcsByEnd.set(startPoint, [arc]);\n    if (endArcs) endArcs.push(arc); else arcsByEnd.set(endPoint, [arc]);\n    arcs.push(arc);\n  }\n\n  function dedupRing(arc) {\n    var endPoint,\n        endArcs,\n        endArc,\n        i, n;\n\n    // Does this arc match an existing line in order, or reverse order?\n    // Rings are closed, so their start point and end point is the same.\n    if (endArcs = arcsByEnd.get(endPoint = coordinates[arc[0]])) {\n      for (i = 0, n = endArcs.length; i < n; ++i) {\n        endArc = endArcs[i];\n        if (equalRing(endArc, arc)) {\n          arc[0] = endArc[0];\n          arc[1] = endArc[1];\n          return;\n        }\n        if (reverseEqualRing(endArc, arc)) {\n          arc[0] = endArc[1];\n          arc[1] = endArc[0];\n          return;\n        }\n      }\n    }\n\n    // Otherwise, does this arc match an existing ring in order, or reverse order?\n    if (endArcs = arcsByEnd.get(endPoint = coordinates[arc[0] + findMinimumOffset(arc)])) {\n      for (i = 0, n = endArcs.length; i < n; ++i) {\n        endArc = endArcs[i];\n        if (equalRing(endArc, arc)) {\n          arc[0] = endArc[0];\n          arc[1] = endArc[1];\n          return;\n        }\n        if (reverseEqualRing(endArc, arc)) {\n          arc[0] = endArc[1];\n          arc[1] = endArc[0];\n          return;\n        }\n      }\n    }\n\n    if (endArcs) endArcs.push(arc); else arcsByEnd.set(endPoint, [arc]);\n    arcs.push(arc);\n  }\n\n  function equalLine(arcA, arcB) {\n    var ia = arcA[0], ib = arcB[0],\n        ja = arcA[1], jb = arcB[1];\n    if (ia - ja !== ib - jb) return false;\n    for (; ia <= ja; ++ia, ++ib) if (!equalPoint(coordinates[ia], coordinates[ib])) return false;\n    return true;\n  }\n\n  function reverseEqualLine(arcA, arcB) {\n    var ia = arcA[0], ib = arcB[0],\n        ja = arcA[1], jb = arcB[1];\n    if (ia - ja !== ib - jb) return false;\n    for (; ia <= ja; ++ia, --jb) if (!equalPoint(coordinates[ia], coordinates[jb])) return false;\n    return true;\n  }\n\n  function equalRing(arcA, arcB) {\n    var ia = arcA[0], ib = arcB[0],\n        ja = arcA[1], jb = arcB[1],\n        n = ja - ia;\n    if (n !== jb - ib) return false;\n    var ka = findMinimumOffset(arcA),\n        kb = findMinimumOffset(arcB);\n    for (var i = 0; i < n; ++i) {\n      if (!equalPoint(coordinates[ia + (i + ka) % n], coordinates[ib + (i + kb) % n])) return false;\n    }\n    return true;\n  }\n\n  function reverseEqualRing(arcA, arcB) {\n    var ia = arcA[0], ib = arcB[0],\n        ja = arcA[1], jb = arcB[1],\n        n = ja - ia;\n    if (n !== jb - ib) return false;\n    var ka = findMinimumOffset(arcA),\n        kb = n - findMinimumOffset(arcB);\n    for (var i = 0; i < n; ++i) {\n      if (!equalPoint(coordinates[ia + (i + ka) % n], coordinates[jb - (i + kb) % n])) return false;\n    }\n    return true;\n  }\n\n  // Rings are rotated to a consistent, but arbitrary, start point.\n  // This is necessary to detect when a ring and a rotated copy are dupes.\n  function findMinimumOffset(arc) {\n    var start = arc[0],\n        end = arc[1],\n        mid = start,\n        minimum = mid,\n        minimumPoint = coordinates[mid];\n    while (++mid < end) {\n      var point = coordinates[mid];\n      if (point[0] < minimumPoint[0] || point[0] === minimumPoint[0] && point[1] < minimumPoint[1]) {\n        minimum = mid;\n        minimumPoint = point;\n      }\n    }\n    return minimum - start;\n  }\n\n  return topology;\n}\n","// Extracts the lines and rings from the specified hash of geometry objects.\n//\n// Returns an object with three properties:\n//\n// * coordinates - shared buffer of [x, y] coordinates\n// * lines - lines extracted from the hash, of the form [start, end]\n// * rings - rings extracted from the hash, of the form [start, end]\n//\n// For each ring or line, start and end represent inclusive indexes into the\n// coordinates buffer. For rings (and closed lines), coordinates[start] equals\n// coordinates[end].\n//\n// For each line or polygon geometry in the input hash, including nested\n// geometries as in geometry collections, the `coordinates` array is replaced\n// with an equivalent `arcs` array that, for each line (for line string\n// geometries) or ring (for polygon geometries), points to one of the above\n// lines or rings.\nexport default function(objects) {\n  var index = -1,\n      lines = [],\n      rings = [],\n      coordinates = [];\n\n  function extractGeometry(geometry) {\n    if (geometry && extractGeometryType.hasOwnProperty(geometry.type)) extractGeometryType[geometry.type](geometry);\n  }\n\n  var extractGeometryType = {\n    GeometryCollection: function(o) { o.geometries.forEach(extractGeometry); },\n    LineString: function(o) { o.arcs = extractLine(o.arcs); },\n    MultiLineString: function(o) { o.arcs = o.arcs.map(extractLine); },\n    Polygon: function(o) { o.arcs = o.arcs.map(extractRing); },\n    MultiPolygon: function(o) { o.arcs = o.arcs.map(extractMultiRing); }\n  };\n\n  function extractLine(line) {\n    for (var i = 0, n = line.length; i < n; ++i) coordinates[++index] = line[i];\n    var arc = {0: index - n + 1, 1: index};\n    lines.push(arc);\n    return arc;\n  }\n\n  function extractRing(ring) {\n    for (var i = 0, n = ring.length; i < n; ++i) coordinates[++index] = ring[i];\n    var arc = {0: index - n + 1, 1: index};\n    rings.push(arc);\n    return arc;\n  }\n\n  function extractMultiRing(rings) {\n    return rings.map(extractRing);\n  }\n\n  for (var key in objects) {\n    extractGeometry(objects[key]);\n  }\n\n  return {\n    type: \"Topology\",\n    coordinates: coordinates,\n    lines: lines,\n    rings: rings,\n    objects: objects\n  };\n}\n","// Given an array of arcs in absolute (but already quantized!) coordinates,\n// converts to fixed-point delta encoding.\n// This is a destructive operation that modifies the given arcs!\nexport default function(arcs) {\n  var i = -1,\n      n = arcs.length;\n\n  while (++i < n) {\n    var arc = arcs[i],\n        j = 0,\n        k = 1,\n        m = arc.length,\n        point = arc[0],\n        x0 = point[0],\n        y0 = point[1],\n        x1,\n        y1;\n\n    while (++j < m) {\n      point = arc[j], x1 = point[0], y1 = point[1];\n      if (x1 !== x0 || y1 !== y0) arc[k++] = [x1 - x0, y1 - y0], x0 = x1, y0 = y1;\n    }\n\n    if (k === 1) arc[k++] = [0, 0]; // Each arc must be an array of two or more positions.\n\n    arc.length = k;\n  }\n\n  return arcs;\n}\n","export default function(topology) {\n  var oldObjects = topology.objects,\n      newObjects = {},\n      oldArcs = topology.arcs,\n      oldArcsLength = oldArcs.length,\n      oldIndex = -1,\n      newIndexByOldIndex = new Array(oldArcsLength),\n      newArcsLength = 0,\n      newArcs,\n      newIndex = -1,\n      key;\n\n  function scanGeometry(input) {\n    switch (input.type) {\n      case \"GeometryCollection\": input.geometries.forEach(scanGeometry); break;\n      case \"LineString\": scanArcs(input.arcs); break;\n      case \"MultiLineString\": input.arcs.forEach(scanArcs); break;\n      case \"Polygon\": input.arcs.forEach(scanArcs); break;\n      case \"MultiPolygon\": input.arcs.forEach(scanMultiArcs); break;\n    }\n  }\n\n  function scanArc(index) {\n    if (index < 0) index = ~index;\n    if (!newIndexByOldIndex[index]) newIndexByOldIndex[index] = 1, ++newArcsLength;\n  }\n\n  function scanArcs(arcs) {\n    arcs.forEach(scanArc);\n  }\n\n  function scanMultiArcs(arcs) {\n    arcs.forEach(scanArcs);\n  }\n\n  function reindexGeometry(input) {\n    var output;\n    switch (input.type) {\n      case \"GeometryCollection\": output = {type: \"GeometryCollection\", geometries: input.geometries.map(reindexGeometry)}; break;\n      case \"LineString\": output = {type: \"LineString\", arcs: reindexArcs(input.arcs)}; break;\n      case \"MultiLineString\": output = {type: \"MultiLineString\", arcs: input.arcs.map(reindexArcs)}; break;\n      case \"Polygon\": output = {type: \"Polygon\", arcs: input.arcs.map(reindexArcs)}; break;\n      case \"MultiPolygon\": output = {type: \"MultiPolygon\", arcs: input.arcs.map(reindexMultiArcs)}; break;\n      default: return input;\n    }\n    if (input.id != null) output.id = input.id;\n    if (input.bbox != null) output.bbox = input.bbox;\n    if (input.properties != null) output.properties = input.properties;\n    return output;\n  }\n\n  function reindexArc(oldIndex) {\n    return oldIndex < 0 ? ~newIndexByOldIndex[~oldIndex] : newIndexByOldIndex[oldIndex];\n  }\n\n  function reindexArcs(arcs) {\n    return arcs.map(reindexArc);\n  }\n\n  function reindexMultiArcs(arcs) {\n    return arcs.map(reindexArcs);\n  }\n\n  for (key in oldObjects) {\n    scanGeometry(oldObjects[key]);\n  }\n\n  newArcs = new Array(newArcsLength);\n\n  while (++oldIndex < oldArcsLength) {\n    if (newIndexByOldIndex[oldIndex]) {\n      newIndexByOldIndex[oldIndex] = ++newIndex;\n      newArcs[newIndex] = oldArcs[oldIndex];\n    }\n  }\n\n  for (key in oldObjects) {\n    newObjects[key] = reindexGeometry(oldObjects[key]);\n  }\n\n  return {\n    type: \"Topology\",\n    bbox: topology.bbox,\n    transform: topology.transform,\n    objects: newObjects,\n    arcs: newArcs\n  };\n}\n","import prune from \"./prune\";\n\nexport default function(topology, filter) {\n  var oldObjects = topology.objects,\n      newObjects = {},\n      key;\n\n  if (filter == null) filter = filterTrue;\n\n  function filterGeometry(input) {\n    var output, arcs;\n    switch (input.type) {\n      case \"Polygon\": {\n        arcs = filterRings(input.arcs);\n        output = arcs ? {type: \"Polygon\", arcs: arcs} : {type: null};\n        break;\n      }\n      case \"MultiPolygon\": {\n        arcs = input.arcs.map(filterRings).filter(filterIdentity);\n        output = arcs.length ? {type: \"MultiPolygon\", arcs: arcs} : {type: null};\n        break;\n      }\n      case \"GeometryCollection\": {\n        arcs = input.geometries.map(filterGeometry).filter(filterNotNull);\n        output = arcs.length ? {type: \"GeometryCollection\", geometries: arcs} : {type: null};\n        break;\n      }\n      default: return input;\n    }\n    if (input.id != null) output.id = input.id;\n    if (input.bbox != null) output.bbox = input.bbox;\n    if (input.properties != null) output.properties = input.properties;\n    return output;\n  }\n\n  function filterRings(arcs) {\n    return arcs.length && filterExteriorRing(arcs[0]) // if the exterior is small, ignore any holes\n        ? [arcs[0]].concat(arcs.slice(1).filter(filterInteriorRing))\n        : null;\n  }\n\n  function filterExteriorRing(ring) {\n    return filter(ring, false);\n  }\n\n  function filterInteriorRing(ring) {\n    return filter(ring, true);\n  }\n\n  for (key in oldObjects) {\n    newObjects[key] = filterGeometry(oldObjects[key]);\n  }\n\n  return prune({\n    type: \"Topology\",\n    bbox: topology.bbox,\n    transform: topology.transform,\n    objects: newObjects,\n    arcs: topology.arcs\n  });\n}\n\nfunction filterTrue() {\n  return true;\n}\n\nfunction filterIdentity(x) {\n  return x;\n}\n\nfunction filterNotNull(geometry) {\n  return geometry.type != null;\n}\n","export default function(topology) {\n  var ownerByArc = new Array(topology.arcs.length), // arc index -> index of unique associated ring, or -1 if used by multiple rings\n      ownerIndex = 0,\n      key;\n\n  function testGeometry(o) {\n    switch (o.type) {\n      case \"GeometryCollection\": o.geometries.forEach(testGeometry); break;\n      case \"Polygon\": testArcs(o.arcs); break;\n      case \"MultiPolygon\": o.arcs.forEach(testArcs); break;\n    }\n  }\n\n  function testArcs(arcs) {\n    for (var i = 0, n = arcs.length; i < n; ++i, ++ownerIndex) {\n      for (var ring = arcs[i], j = 0, m = ring.length; j < m; ++j) {\n        var arc = ring[j];\n        if (arc < 0) arc = ~arc;\n        var owner = ownerByArc[arc];\n        if (owner == null) ownerByArc[arc] = ownerIndex;\n        else if (owner !== ownerIndex) ownerByArc[arc] = -1;\n      }\n    }\n  }\n\n  for (key in topology.objects) {\n    testGeometry(topology.objects[key]);\n  }\n\n  return function(ring) {\n    for (var j = 0, m = ring.length, arc; j < m; ++j) {\n      if (ownerByArc[(arc = ring[j]) < 0 ? ~arc : arc] === -1) {\n        return true;\n      }\n    }\n    return false;\n  };\n}\n","export function planarTriangleArea(triangle) {\n  var a = triangle[0], b = triangle[1], c = triangle[2];\n  return Math.abs((a[0] - c[0]) * (b[1] - a[1]) - (a[0] - b[0]) * (c[1] - a[1])) / 2;\n}\n\nexport function planarRingArea(ring) {\n  var i = -1, n = ring.length, a, b = ring[n - 1], area = 0;\n  while (++i < n) a = b, b = ring[i], area += a[0] * b[1] - a[1] * b[0];\n  return Math.abs(area) / 2;\n}\n","import {feature} from \"topojson-client\";\nimport {planarRingArea} from \"./planar\";\n\nexport default function(topology, minWeight, weight) {\n  minWeight = minWeight == null ? Number.MIN_VALUE : +minWeight;\n\n  if (weight == null) weight = planarRingArea;\n\n  return function(ring, interior) {\n    return weight(feature(topology, {type: \"Polygon\", arcs: [ring]}).geometry.coordinates[0], interior) >= minWeight;\n  };\n}\n","import filterAttached from \"./filterAttached\";\nimport filterWeight from \"./filterWeight\";\n\nexport default function(topology, minWeight, weight) {\n  var a = filterAttached(topology),\n      w = filterWeight(topology, minWeight, weight);\n  return function(ring, interior) {\n    return a(ring, interior) || w(ring, interior);\n  };\n}\n","function compare(a, b) {\n  return a[1][2] - b[1][2];\n}\n\nexport default function() {\n  var heap = {},\n      array = [],\n      size = 0;\n\n  heap.push = function(object) {\n    up(array[object._ = size] = object, size++);\n    return size;\n  };\n\n  heap.pop = function() {\n    if (size <= 0) return;\n    var removed = array[0], object;\n    if (--size > 0) object = array[size], down(array[object._ = 0] = object, 0);\n    return removed;\n  };\n\n  heap.remove = function(removed) {\n    var i = removed._, object;\n    if (array[i] !== removed) return; // invalid request\n    if (i !== --size) object = array[size], (compare(object, removed) < 0 ? up : down)(array[object._ = i] = object, i);\n    return i;\n  };\n\n  function up(object, i) {\n    while (i > 0) {\n      var j = ((i + 1) >> 1) - 1,\n          parent = array[j];\n      if (compare(object, parent) >= 0) break;\n      array[parent._ = i] = parent;\n      array[object._ = i = j] = object;\n    }\n  }\n\n  function down(object, i) {\n    while (true) {\n      var r = (i + 1) << 1,\n          l = r - 1,\n          j = i,\n          child = array[j];\n      if (l < size && compare(array[l], child) < 0) child = array[j = l];\n      if (r < size && compare(array[r], child) < 0) child = array[j = r];\n      if (j === i) break;\n      array[child._ = i] = child;\n      array[object._ = i = j] = object;\n    }\n  }\n\n  return heap;\n}\n","import {transform} from \"topojson-client\";\nimport newHeap from \"./heap\";\nimport {planarTriangleArea} from \"./planar\";\n\nfunction copy(point) {\n  return [point[0], point[1], 0];\n}\n\nexport default function(topology, weight) {\n  var point = topology.transform ? transform(topology.transform) : copy,\n      heap = newHeap();\n\n  if (weight == null) weight = planarTriangleArea;\n\n  var arcs = topology.arcs.map(function(arc) {\n    var triangles = [],\n        maxWeight = 0,\n        triangle,\n        i,\n        n;\n\n    arc = arc.map(point);\n\n    for (i = 1, n = arc.length - 1; i < n; ++i) {\n      triangle = [arc[i - 1], arc[i], arc[i + 1]];\n      triangle[1][2] = weight(triangle);\n      triangles.push(triangle);\n      heap.push(triangle);\n    }\n\n    // Always keep the arc endpoints!\n    arc[0][2] = arc[n][2] = Infinity;\n\n    for (i = 0, n = triangles.length; i < n; ++i) {\n      triangle = triangles[i];\n      triangle.previous = triangles[i - 1];\n      triangle.next = triangles[i + 1];\n    }\n\n    while (triangle = heap.pop()) {\n      var previous = triangle.previous,\n          next = triangle.next;\n\n      // If the weight of the current point is less than that of the previous\n      // point to be eliminated, use the latters weight instead. This ensures\n      // that the current point cannot be eliminated without eliminating\n      // previously- eliminated points.\n      if (triangle[1][2] < maxWeight) triangle[1][2] = maxWeight;\n      else maxWeight = triangle[1][2];\n\n      if (previous) {\n        previous.next = next;\n        previous[2] = triangle[2];\n        update(previous);\n      }\n\n      if (next) {\n        next.previous = previous;\n        next[0] = triangle[0];\n        update(next);\n      }\n    }\n\n    return arc;\n  });\n\n  function update(triangle) {\n    heap.remove(triangle);\n    triangle[1][2] = weight(triangle);\n    heap.push(triangle);\n  }\n\n  return {\n    type: \"Topology\",\n    bbox: topology.bbox,\n    objects: topology.objects,\n    arcs: arcs\n  };\n}\n","export default function(topology, p) {\n  var array = [];\n\n  topology.arcs.forEach(function(arc) {\n    arc.forEach(function(point) {\n      if (isFinite(point[2])) { // Ignore endpoints, whose weight is Infinity.\n        array.push(point[2]);\n      }\n    });\n  });\n\n  return array.length && quantile(array.sort(descending), p);\n}\n\nfunction quantile(array, p) {\n  if (!(n = array.length)) return;\n  if ((p = +p) <= 0 || n < 2) return array[0];\n  if (p >= 1) return array[n - 1];\n  var n,\n      h = (n - 1) * p,\n      i = Math.floor(h),\n      a = array[i],\n      b = array[i + 1];\n  return a + (b - a) * (h - i);\n}\n\nfunction descending(a, b) {\n  return b - a;\n}\n","export default function(topology, minWeight) {\n  minWeight = minWeight == null ? Number.MIN_VALUE : +minWeight;\n\n  // Remove points whose weight is less than the minimum weight.\n  var arcs = topology.arcs.map(function(input) {\n    var i = -1,\n        j = 0,\n        n = input.length,\n        output = new Array(n), // pessimistic\n        point;\n\n    while (++i < n) {\n      if ((point = input[i])[2] >= minWeight) {\n        output[j++] = [point[0], point[1]];\n      }\n    }\n\n    output.length = j;\n    return output;\n  });\n\n  return {\n    type: \"Topology\",\n    transform: topology.transform,\n    bbox: topology.bbox,\n    objects: topology.objects,\n    arcs: arcs\n  };\n}\n","var pi = Math.PI,\n    tau = 2 * pi,\n    quarterPi = pi / 4,\n    radians = pi / 180,\n    abs = Math.abs,\n    atan2 = Math.atan2,\n    cos = Math.cos,\n    sin = Math.sin;\n\nfunction halfArea(ring, closed) {\n  var i = 0,\n      n = ring.length,\n      sum = 0,\n      point = ring[closed ? i++ : n - 1],\n      lambda0, lambda1 = point[0] * radians,\n      phi1 = (point[1] * radians) / 2 + quarterPi,\n      cosPhi0, cosPhi1 = cos(phi1),\n      sinPhi0, sinPhi1 = sin(phi1);\n\n  for (; i < n; ++i) {\n    point = ring[i];\n    lambda0 = lambda1, lambda1 = point[0] * radians;\n    phi1 = (point[1] * radians) / 2 + quarterPi;\n    cosPhi0 = cosPhi1, cosPhi1 = cos(phi1);\n    sinPhi0 = sinPhi1, sinPhi1 = sin(phi1);\n\n    // Spherical excess E for a spherical triangle with vertices: south pole,\n    // previous point, current point.  Uses a formula derived from Cagnolis\n    // theorem.  See Todhunter, Spherical Trig. (1871), Sec. 103, Eq. (2).\n    // See https://github.com/d3/d3-geo/blob/master/README.md#geoArea\n    var dLambda = lambda1 - lambda0,\n        sdLambda = dLambda >= 0 ? 1 : -1,\n        adLambda = sdLambda * dLambda,\n        k = sinPhi0 * sinPhi1,\n        u = cosPhi0 * cosPhi1 + k * cos(adLambda),\n        v = k * sdLambda * sin(adLambda);\n    sum += atan2(v, u);\n  }\n\n  return sum;\n}\n\nexport function sphericalRingArea(ring, interior) {\n  var sum = halfArea(ring, true);\n  if (interior) sum *= -1;\n  return (sum < 0 ? tau + sum : sum) * 2;\n}\n\nexport function sphericalTriangleArea(t) {\n  return abs(halfArea(t, false)) * 2;\n}\n"],"sourceRoot":""}